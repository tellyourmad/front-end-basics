正课：
1. 错误处理
2. *****Function

1. 错误处理: 
  错误: 程序在执行过程中遇到的异常中断
      当发生错误时，程序会报错，退出。
  错误处理: 即使发生错误，也保证程序不中断退出的机制。
  如何: 
    try{
      可能发生错误的正常逻辑
    }catch(err){
      只有发生错误时才执行的错误处理代码:	
      //包括: 1. 记录日志: 
            //2. 提示用户
            //3. 保存数据
    }finally{
      //无论是否出错，都一定会执行的代码
      //包括: 释放内存
    }
  其中err:
   一旦try中的程序发生错误，js会自动创建一个Error类型的对象。
   Error:专门封装错误信息的对象。
     6种:
     SyntaxError: 语法错误
     ReferenceError: 引用错误，要使用的变量，或对象，没找到。
     TypeError: 类型错误,指错误的使用了类型的方法。
     RangeError: 参数超范围

     URIError,EvalError

  如果可以提前预知错误的原因，就可用if...else...代替try catch
  
  判断浏览器兼容性:
  try{
   new XMLHttpRequest
();
   提示: 支持Ajax
  }catch(){
   提示: 不支持Ajax
  }
  也可用if...else代替
  
  鄙视题: try catch中的return
    如果finally中有return，则使用finally中的return返回
    如果finally中没有return，try中的return，会先获得要返回的值，但挂起，暂不返回。要等待finally中代码执行完，才返回。

  主动抛出错误:
   何时: 当API的开发者，向API的调用者提示错误时。
   如何抛出: throw new Error("信息")

2.*****Function
  js中的一切函数都是一个对象
  创建函数: 3种:
   1. 声明方式:
     function 函数名(参数列表){
       函数体;
       return 返回值;
     }――被声明提前(hoist)
     其中:function是创建一个新函数的意思
         函数其实是一个对象
	   函数对象中封装的不是数据，而是代码段。
         函数名仅是引用函数对象的普通变量
   2. 函数直接量:
     var 函数名=function(参数列表){
     不会被声明提前。
     何时: 如果不希望函数定义被提前时，就必须用直接量。
   3. 用new:
   var 函数名=
     new Function("参数名1",...,"函数体")
    何时: 如果函数的参数名和函数体可能在运行时动态生成。

***重载(overload): 相同函数名，不同参数列表的多个函数，在调用时，可根据传入的参数不同，自动选择对应的函数执行。
  为什么: 为了减少函数的个数，减轻使用者的负担。
  如何: js中默认不支持重载的语法
   变通: arguments对象
    函数中自动创建的，接收所有传入函数的参数值得类数组对象。
      类数组对象: 长的像数组的对象
        vs 数组: 相同: 1. 用下标访问元素
                       2. length属性
           不同: 不是数组类型，无法使用数组类型的API。






