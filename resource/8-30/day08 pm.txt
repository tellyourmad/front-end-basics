正课：
1. String中的正则API
2. RegExp

1. String中的正则API:
检索: 4种:
  1. 查找一个固定关键词的位置
    var i=str.indexOf("关键词",fromi);
    var i=str.lastIndexOf("关键词",fromi)
    问题: 不支持正则
  2. 判断字符串中是否包含符合规则的关键词
    var i=str.search(/正则/);
      始终返回第一个关键词的位置
      如果没找到，返回-1
     问题: 1. 只能找第一个
           2. 只能获得位置，无法获得内容
  3. 获得每个关键词的内容: 
    var kwords=str.match(/正则/ig);
      获取str中所有和正则匹配的关键词
      返回: 一个包含所有关键词的数组
          没找到，返回null
      强调: 只要一个方法可能返回null，就都要先验证不是null，再使用。
      强调: 所有正则表达式默认只匹配一个关键词。除非在第二个/后加g,表示全部。
          如果希望忽略大小写: 加i
     问题: 无法获得每个关键词的位置

    如果match不加g:
      仅返回第一个关键词的内容和位置
      kwords:[0:"关键词",index:i]

   4. 即获得每个关键词的内容，又获得每个关键词的位置？

替换: 将str中和正则匹配的敏感词替换为指定内容。
  str=str.replace(/正则/ig,"替换值");
  高级: 如果希望根据关键词的不同，替换不同的内容时:  
  str=str.replace(/正则/ig,
    function(kwd,$1,...){
      return 根据kwd返回不同的值;
    } 
  )
  
  $1,$2,...:如果需要对关键词中部分内容单独处理时:2步:
     1. 在正则中用()，将要单独操作的部分分组。在匹配时，每个分组会自动获得从1开始，连续不重复的序号
     2. 在replace内部的函数的参数中可用$1,$2...获得第i个分组的子内容。

  练习: 
  补:正则: 
   \b: 单词边界: ^ 空格 标点 $
   何时使用: 今后，只要匹配单词，必须前后加\b。
  
  扩展:
    1. 删除:将关键词替换为空字符串:
    2. 格式化: 2步:
       1. 用正则将原字符串分组
       2. 在replace第二个参数中用$i方式拼接新的格式。

  补:正则: 一位汉字:[\u4e00-\u9fa5]

切割: 将字符串，按匹配的分隔符，分割为多个子字符串
  var subs=str.split(/正则/);





