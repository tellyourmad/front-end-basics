回顾:
1.OOP:
 创建:
   1. 直接量:
     var obj={
      属性名:值,
      方法名:function(){
        this.属性名
      }
     }
   2. 用new:
     var obj=new Object();
     obj.属性名=值;
     obj.方法名=funciton(){
       this.属性名;
     }
   3. 用构造函数，反复创建多个相同结构的对象
     2步: 
     1. 定义构造函数:
       function 类型名(属性参数列表){
         this.属性名=属性参数;
         this.方法名=function(){
           this.属性名...
         }
       }
   
       优: 代码重用
       缺: 没有解决内存浪费的问题

     2. 用new调用构造函数:
       ――实例化(instance)一个xxx类型的对象。
      var obj=new 类型名(属性值列表)
       其中:obj也成为xx类型的一个实例
 访问对象成员:
   obj.属性名 => obj["属性名"]
   obj.方法名();

 本质: js中一切对象底层都是hash数组，属性名是字符串类型的key，属性值是value。

正课:
1.*****OOP:
面向对象的理解: 
  面向对象三大特点:
   封装:将一个/一类事物的属性和功能集中定义在一个对象中 
     为了代码重用！
   继承:父对象中的成员，子对象无需重复创建，即可直接使用。
     为了即代码重用，又节约内存
   多态:同一个方法,在不同情况下，表现出不同的状态。
     为了体现子对象与父对象之间的差异。

继承: js中的继承都是通过原型对象实现的
    也成为: 原型继承/继承原型
 原型对象(prototype): 集中存储一类对象共有成员的父对象。
   何时: 只要多个子对象中，拥有相同的成员，就都要集中定义在父对象(原型对象)中一份，然后所有子对象共用!
   如何: 
    创建: 在创建构造函数时，会自动创建该类型的原型对象prototype
    何时继承: 
     new: 2. 设置新对象的__proto__属性继承构造函数的原型对象
    如何向原型对象中添加共有成员:
     类型名.prototype.共有成员名=值 

  原型链: 由各级父对象逐级继承，实现的链式结构。
    任何对象都有__proto__继承其父对象
    Object.prototype是所有对象的顶级父对象。Object.prototype.__proto__是null
    Function.prototype是所有函数对象的父对象。Function.prototype.__proto__是Object.prototype
    原型链控制着成员的使用顺序: 
     优先使用当前对象本地的自有成员
     如果自己没有，才延原型链向父级找
     如果到Object.prototype没找到，返回undefined。
    vs 作用域链: 控制着变量的使用顺序
  不带.直接访问的变量，走作用域链
  带.访问的对象成员，都走原型链

  正确的访问对象的成员: 
   原则: 
    修改原型链上的共有成员:必须用父对象改
    修改自有成员: 必须用当前子对象本身
    错误: 禁止使用子对象修改共有成员
  如何判断成员是自有还是共有:
    自有: 直接定义在当前对象本地的成员
    共有: 对象本地没有，从原型链上继承来的成员。
    判断自有: 
    var bool=obj.hasOwnProperty("成员名")
      判断"成员名"是否直接定义在obj本地
      如果是自有，就返回true，
      否则返回false
    判断共有:
      不是自有，且原型链上有
      !obj.hasOwnProperty("成员名")
       &&(obj.成员!==undefined)
          或 "成员名" in obj
       in: 判断"成员名"是否包含在obj的原型链上。（可检查整个原型链）

  删除: delete obj.属性名
    不能用子对象删除共有属性









