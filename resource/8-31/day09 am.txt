回顾: 
1. 正则:
  1. 最简单的正则就是关键词原文
  2. 字符集: [备选字符列表]
     简写: [A-Za-z] [0-9] [\u4e00-\u9fa5]
     除了: [^xxx]
  3. 预定义字符集:
      \d => [0-9]
      \w => [A-Za-z0-9_]
      \s => 空字符: 空格，制表符...
      . => 除回车换行外的一切字符
  4. 量词: 
      1. 有明确数量限制:
         字符集{n,m} 至少n次，最多m次
         字符集{n,} 至少n次，多了不限
         字符集{n}  必须n次，不能多也不能少
      2. 没有明确数量:
         字符集?  可有可无，最多一次
         字符集*  可有可无，多了不限
         字符集+  至少一次，多了不限
  5. 选择和分组:
    规则1|规则2
    (规则1规则2)
      每个分组会自动获得一个从1开始连续不重复的需要
  6. 指定匹配位置:
    ^ 字符串开头
    $ 字符串结尾
    \b 单词边界
  7. 密码强度: 预判
    6~8位字母和数字的组合，至少包含一位大写字母和一位数字
    (?![A-Za-z]+$)(?![a-z0-9]+$)[A-Za-z0-9]{6,8} 

2. String中的正则API:
检索:
  1. 查找一个固定关键词出现的位置
   var i=str.indexOf("关键词",fromi)
   var i=str.lastIndexOf("关键词",fromi)
  2. 判断是否包含符合规则的关键词:
   var i=str.search(/正则/i)
  3. 获得所有关键词的内容: 
   var kws=str.match(/正则/ig);
   如果不加g:
     match也相当于search，但可获得关键词内容: [0:"关键词",index:i]
  4. 即获得每个关键词的内容，又获得每个关键词的位置: reg.exec(str)
   
替换:
 简单:将所有关键词替换为统一的替换值
   str=str.replace(/正则/ig,"替换值");
 高级:根据关键词的不同，替换不同的值
   str=str.replace(/正则/ig,
      function(kw,$1,$2,...){
        return 根据kw判断返回不用替换值         }
   );
 扩展: 
   1. 删除: 将关键词替换为""
   2. 格式化: 2步:
     1. 用正则将原字符串分组
     2. 在replace的第二个参数中用$i拼接出新的内容。

切割:
  var subStrs=str.split(/正则/);
    固定套路: var chars=str.split("")

正课:
1. RegExp
2. Math
3. Date

1. RegExp: 封装一条正则表达式，并提供用正则执行验证和查找的方法的对象
 何时使用: 
  检索: 即检索每个关键词内容，又检索位置
  验证: 检查字符串是否符合正则表达式的要求

 如何使用: 
  创建: 2种:
   1. 只用正则直接量: var reg=/正则/ig;
     何时使用: 如果正则表达式是固定的，不需要动态生成。
     特殊符号: 直接量中的/都要转为\/ 
       /<\/li><li>/
   2. 用new: 
    var reg=new RegExp("正则","ig");
     何时使用: 如果正则表达式不是固定的，需要动态生成
     特殊符号: 
       \ " '都要转义为:\\ \"  \'
     "\\d{6}" "href=[\'\"]..."

RegExp API:
检索: 即检索每个关键词的内容，又检索每个关键词的位置
  var arr=reg.exec(str)
    找出str中当前位置后和reg匹配的下一个关键词。
  原理: 
    reg.lastIndex: 标识下次开始查找的位置
        默认0
    exec: 每执行一次,做3件事:
     1. 从reg.lastIndex位置开始找下一个关键词
     2. 返回:
       [0:"关键词",1:"$1",2:"$2",...]
       .index-> 返回本次找到的关键词位置
       强调: 如果找不到,返回null
     3. 自动修改reg.lastIndex为index+关键词的字符个数(跳过当前关键词)

  练习: 
   正则: 
   贪婪模式: 默认正则表达式都会匹配尽量长的符合规则的字符串。
   懒惰模式: 仅匹配最短的符合规则的字符串
     贪婪改懒惰?  .*?  .+?

验证: 检查一个字符串是否符合正则表达式的要求。
  var bool=reg.test(str);
     检查str是否符合reg的要求
     如果符合，返回true，否则返回false
  问题:默认test方法只要部分匹配就返回true。
  解决:验证都要前加^，后加$,要求从头到尾必须完整匹配。

2. Math: 专门封装数学计算使用的常量，并提供执行数学计算的API的对象
    强调: 不能new！直接使用Math.xxx
Math API:
取整:
  1. 上取整: 只要超过，就取下一个整数
    Math.ceil(n);
  2. 下取整: 只要超过，就去掉小数部分]
    Math.floor(n);
  3. 四舍五入取整: Math.round(n) 
   vs n.toFixed(d)
   Math.round只能取整，返回的是number
   而n.toFixed(d),可指定小数位数,但返回的是string
   自定义round:
   
乘方和开平方:
  Math.pow(底数,幂) : 计算乘方
   比如: 10的2次方: Math.pow(10,2);
  Math.sqrt(n):求n的平方根
   





